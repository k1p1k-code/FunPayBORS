# Важно
- *Важно это максимальна сырая функция которая будет дорабатываться и расширяться*
- *В скором времени будет полная подержка хуков на данный момент толькой один*
_____

# Начало
Установите python 3.13.2 до 3.13.6
## Настройка
1. Установите версию из realese под которую хотите начать разработку лучше всего выбирать последнию или самую стбильную на момент написание данного урока нету стабильный)) откройте консоль
2. Создайте рядом с исполняемом файлом папку /plugins 
3. Создайте виртуальное окружение в папке plugins с названием venv важно
4. Придумайте уникальное название плагину и назовите так папку в /plugins
5. Перейдите в новую папку все дальнейшие деяствия происходят там
6. Создайте файл plugin.py это входной файл 
7. В этом файле создайте класс Plugin

## Хуки
За короткое время добавиться очень много хуков

Хук load отвечает за выполнение кода при старте скрипта

Все остальные хуки асинхроные

| Хук | Описание | Входные данные |
| --- | --- | --- |
| message_hook | Получает данные о сообщение  |     id: int,    chat_id: str,    chat_name: Option,    text: Option,    interlocutor_id: Option,    author_id: int, |

Массивные данные(которые даються каждому хуку)
me: str - golden_key: str, id: int

*Выходные данные из хука это bool* 
- True - Хендлер проходит по всем остальным хукам (по всем плагином)
- False - Плагин говорит я забираю данный хендлер дальше его не раздавай
- Понятное дело несколько хуков из разных плагинов могут читать одно и тот же хук важное что играет ключевою роль это добавление в папку чем выше сортирует ос папку тем первее она будет в вызове хуков

## Использование хуков
```python
class Plugin():
    @staticmethod
    def load() -> None:
        print("Hi plugin super, load!")

    @staticmethod
    async def message_hook(*args) -> bool:
        return True
```
Вы могли заметить то что мы используем *args на входе дело в том то что Rust отдает в кортеже (данные для хука, *масивные данные)
Ну еще важно заметить то что при args мы получаем данные в str но их можно спрасить с помощью json.loads
Но я советую использовать base.py из [plugin_exempel](https://github.com/k1p1k-code/FunPayBORS/tree/master/plugin_exempel)

- Его необходимо положить в папку с plugin.py или поддиректории
- Дальше необходимо его импортировать, но важно производить импорты где мы будем использовать нам нужен дикоратор из base так что мы импортируем в class Plugin

```python
class Plugin():
    from base import message
    @staticmethod
    def load() -> None:
        print("Hi plugin super, load!")

    @staticmethod
    @message
    async def message_hook(message: dict, me: dict) -> bool:
        return True
```
Что делать если мы хотим воспользоваться любой библиотекой из venv или стандартной в хуке то необходимо импортировать в саму функцию

Мне для создание системы плагинов необходимо было посмотреть все пути в sys.path
```python
import sys
# print(sys.path) - сработает при load
# Plugin.load и писать в майне ни чем не отличаеться
class Plugin():
    import sys
    # print(sys.path) - сработает
    from base import  message
    @staticmethod
    def load() -> None:
        print("Hi plugin super, load!")

    @staticmethod
    @message
    async def message_hook(message: dict, me: dict) -> bool:
        # print(Plugin.sys.path) - не сработает
        import sys
        print(sys.path)
        return True
```

*Теперь вы можете создавать плагины на python для бота на funpay написаном на Rust*
